#  异常控制流

计算机系统的运行可以抽象为一组指令的执行，即PC中的序列，而控制着这串序列中前后指令的跳转关系称为控制流。若指令的执行是线性的，则控制流为每次顺序取后一个指令。

现代计算机系统中，要实现如I/O、网络、虚拟内存等必须要求指令可以随时跳转出当前程序处理其他事物，这些突发的事物被称为异常，考虑了异常的控制流即为现在计算机体系的基石：**异常控制流**

### 异常的分类

| 异常类型 | 具体案例                     | 处理时机                         | 处理完后                             |
| -------- | ---------------------------- | -------------------------------- | ------------------------------------ |
| 中断     | I/O中断，时钟中断等硬件中断  | 异步，等待当前指令执行完毕后处理 | 运行下一条指令                       |
| 陷阱     | 程序内有意的异常，如方法调用 | 同步                             | 运行下一条指令                       |
| 故障     | 缺页故障，除0等              | 同步                             | 可能运行下一条指令，也可能重试上一条 |
| 终止     | 程序终止                     | 同步                             | 程序终止                             |

每种异常的处理方式相似，都是在故障处理表中寻找异常处理程序的接口来调用处理。

### Linux进程

进程是一个抽象的概念，可以认为是一个执行中的程序的实例，其中最关键的抽象概念为：

1. 每个进程拥有自己独立的地址空间
2. 每个进程拥有自己独立的逻辑控制流

![截屏2020-08-18 下午8.16.09](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-18 下午8.16.09.png)

进程在内存中的逻辑分布如上图所示，和Java虚拟机的进程分布类似，也有

1. 只读代码段：存储指令
2. 数据段和BSS段：存储静态变量
3. 堆：运行时程序动态申请的空间
4. 内存映射段
5. 栈：存放函数的传入参数,临时变量(jvm中的方法使用的栈帧),以及返回地址等数据

#### JVM作为一个进程和普通进程的比较[🔗](https://www.cnblogs.com/qq289736032/p/9185964.html)

1. jvm将许多本来属于操作系统管理范畴的东西,移植到了jvm内部,目的在于减少系统调用的次数;
   1. 普通进程栈区，在JVM一般仅仅用做线程栈
   2. JVM的堆区和普通进程的差别是最大的
2. JavaNIO,目的在于减少用于读写IO的系统调用的开销

##### 用户内存部分的区别

![JVM和Linux内存的对比](https://img2018.cnblogs.com/blog/1392612/201904/1392612-20190416095559551-1562066624.png)

将堆区划分为老年/永久/...，将栈区只作为线程栈

**代码区储存的是JVM代码而非Java程序的代码！！！！**Java程序的字节码存储在方法区中

JVM的内存管理方式的优点是显而易见的，包括：

- 第一，减少系统调用的次数，JVM在给Java程序分配内存空间时不需要操作系统干预，仅仅在Java堆大小变化时需要向操作系统申请内存或通知回收，而普通程序每次内存空间的分配回收都需要系统调用参与；
- 第二，减少内存泄漏，普通程序没有（或者没有及时）通知操作系统内存空间的释放是内存泄漏的重要原因之一，而由JVM统一管理，可以避免程序员带来的内存泄漏问题。

##### 内核内存部分的区别

![img](https://img2018.cnblogs.com/blog/1392612/201904/1392612-20190416095925160-829042182.png)



这里的nio buffer可以实现I/O数据直接读取至该进程的内核内存内，省去了复制的过程，大大提高了效率

![img](https://img2018.cnblogs.com/blog/1392612/201904/1392612-20190416095946282-150387015.png)

### 进程间通讯

见操作系统.md

# 虚拟内存

虚拟内存的作用

1. 将物理内存进行了拓展，提高了内存的使用效率
2. 为每个进程提供了统一的地址空间（对单个进程而言，其内存地址是连续的一整块），方便操作系统进行管理
3. 增强了对不同进程内存的保护，防止越界（通过在pte中加入额外的许可控制位）

虚拟内存的翻译过程

指令->cpu->MMU->主存，其中进程提供自己的页表给MMU来进行翻译得到物理地址，翻译的过程可以用多级cache进行加速，最后没有找到再发生缺页故障进行处理

按需调度和独立的虚拟地址空间的优点：

1. 简化链接
2. 简化加载
3. 简化共享

虚拟内存中每个页的状态有三种

1. 未分配
2. 已分配未缓存（相当于声明？）
3. 已缓存