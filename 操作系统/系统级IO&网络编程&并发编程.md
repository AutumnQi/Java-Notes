# 系统级I/O

- 类Unix系统中，一个文件被视为m个字节的序列

- 任何I/O设备都被内核抽象化为文件

在此基础上，所有的I/O设备的操作过程都可以统一由read和write两种操作来完成。

内核使用一个非负整数来标记打开的文件，称为**文件描述符**，对于一个Linux进程而言，在被创建之初有三个固定的文件描述符fd

1. 标准输入fd：0
2. 标准输出fd：1
3. 标准错误fd：2

#### Linux系统中有三种不同的文件

1. 普通文件
   1. 文本文件
   2. 二进制文件
2. 目录文件
3. Socket（套接字，用来和其他进程通信）

#### Linux文件的组成

1. 文件头，包含文件的元数据，在内核中由`stat`函数读取，包括文件类型、大小、访问许可、修改时间、访问时间等
2. 文件的数据

#### Linux内核中的文件操作函数

##### 不考虑缓冲的读写

首先用open函数得到文件描述符，再使用read和write函数对文件进行读写，返回的int为读写的字节数，返回-1表示错误，最后使用close函数关闭文件

##### 考虑不稳定情况（如进程被中断、挂起等）的读写

再内存中建立一个缓冲区，将数据先写到缓冲区中，缓冲区满时将数据复制到用户的usr_buffer，写时也是一样

# 网络编程

客户端和服务端的网络编程模型，这里的二者都是指进程，这个过程也可以理解为进程间通信的一种。

所谓的连接，指的就是二者的socket可以建立稳定的互相通信机制，这要求两个进程能唯一确定一个socket用来和对方进行连接，特别是对于服务器而已，可能有多个socket存在于系统中，所以一个连接由两端的socket地址对唯一确定

socket地址由ip地址和端口组成，可以保证两个进程对连接的稳定性。其中，客户端的端口由系统随机生成，而服务器的端口通常是知名端口。

整个连接的过程如下图所示：

![image-20200819001337657](/Users/inlab/Library/Application Support/typora-user-images/image-20200819001337657.png)

### 服务器端

1. 服务器进程执行`get_addr_info`和`socket`来获取客户端的*addr和servefd
2. 使用`bind`函数将服务器自身的*addr和servefd进行绑定
3. 使用`listen`函数将servefd转化为监听套接字，**该listenfd只创建一次，并服务于进程的整个生命周期**
4. 可以用辅助函数`open_clientfd`来实现

### 客户端

1. 客户端进程输入服务器的host、service等参数，调用`get_addr_info`函数来生成一个自己的*addr（网络地址）
2. 客户端进程调用`socket`函数生成一个clientfd（文件描述符）
3. 可以用辅助函数`open_listenfd`来实现

### 互动

1. 客户端进程调用`connect`函数尝试与服务器建立连接，输入为自己的*addr和clientfd（**此处触发三次握手**）
2. 服务器端的listenfd监听到客户端的请求，使用`accept`函数建立起连接（实现方式多种多样，包括fork一个新的进程）（**三次握手结束**）
   - 三次握手的第三次失败时客户端不可知，会向服务器发送数据，此时服务器向其发送警告，并重发第二次握手
   - 服务器在等待一段时间没收到第三次握手也会重发
3. 链接建立完后即可用通用的I/O函数来对socket执行操作

### 终止连接

1. 读取到EOF，指终止信号
2. ？？



# 并发编程

介绍三种并发编程的实现方式

### 基于进程的并发编程

从父进程（有listenfd的进程）中fork得到一个新的子进程作为新的连接

- 优点：每个新的连接有自己独立的地址空间，便于保护和多核运行
- 缺点：无法共享数据，进程间的通讯需要通过显示的通信模块，开销大

### 基于I/O多路复用的并发编程

多个不同的I/O事件同时并发时，将其都放在一个fd_set池中，用select函数来进行选择要执行哪一个链接，每一个fd都可以视作状态机，等待+就绪->读/写，类似一个状态转移的过程，只要规定好每个fd的时间片和优先级，可以保证整个系统高效的运作。

Nginx和Node.js都分别采用这种方式来建立连接

- 优点：
  1. 可以实现由事件驱动的服务器（作为状态转移的输入）
  2. 实现不同fd之间数据的共享而无需使用显式的通信模块
  3. 作为单个进程也便于调试
- 缺点：
  1. 在内部实现一个类似操作系统的调度算法，编码复杂
  2. 容易受到攻击而无法进行服务？
  3. 无法实现多核并行

### 基于线程的并发编程

其实相当于上面两种方式的结合

- 优点：可以方便地共享大部分数据，同时可以实现多核并行
- 缺点：容易产生线程安全问题

Reentrant（可重入）：指被多个线程调用时，不会饮用任何共享数据

![image-20200819005734172](/Users/inlab/Library/Application Support/typora-user-images/image-20200819005734172.png)

