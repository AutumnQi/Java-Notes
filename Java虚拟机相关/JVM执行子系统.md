# JVM执行子系统

> 类文件阅读 -> 类的加载 -> 类中方法的执行

### 1.类文件结构

![截屏2020-08-17 上午9.44.15](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 上午9.44.15.png)

使用od -tx1 文件名查看用16进制展示的二进制class文件

- 前4个字节 **cafebabe** 是class文件的魔数用以识别文件类型
- 5～6个字节为次版本号，7～8个字节为主版本号 0037 表示jdk11
- 9～10个字节 0x00d4=212 表示常量池的索引大小
  - 常量池的索引从1开始，0表示空，不指向任何一个常量
- 第11个字节开始为常量池的表，第一个字节指示常量的类型，如 0x0a 表示类中的方法<img src="/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 上午10.03.09.png" alt="截屏2020-08-17 上午10.03.09" style="zoom:0%;" />
- 使用javap -verbose 文件名 可以更清晰地展示常量池中的表内容![截屏2020-08-17 上午10.21.15](/Users/inlab/Desktop/截屏2020-08-17 上午10.21.15.png)
- 常量池结束后，紧接着的两个字节表示**访问标志**，标注是否为public、收否为接口等
- 访问标志之后是**类索引、父类索引与接口索引集合**，分表表示自己的类名，父类的类名和实现的接口
  - 类索引和父类索引是一个u2值，指向常量池中的某个数据
  - 接口是一组u2值（2个字节），第一个u2表示接口集合的长度
- 索引集合后为字段表，第一个字节为filed count，之后为每个field的数据，不继承父类的field![截屏2020-08-17 上午10.42.06](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 上午10.42.06.png)
- 字段表后是同样格式的方法表，表中不会出现父类的方法但可能由编译器加入一些init函数，方法中的代码被存储在属性表中![截屏2020-08-17 上午10.44.56](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 上午10.44.56.png)
- **属性表**在多个部分被用到，用来记录大部分的数据，不同部分的属性表有不同的格式![截屏2020-08-17 上午10.49.56](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 上午10.49.56.png)
  - 属性表有多种类型，在不同的位置被使用。以下列举了一些使用场景，其中最重要的为code属性![截屏2020-08-17 上午11.25.10](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 上午11.25.10.png)
- code属性表中包含了以下的内容，字节码存储在code部分，max_stack指示分配操作数栈的最大深度，max_local指示局部变量表的最大长度，java线程中私有的java虚拟机栈中就包含了操作数栈，局部变量表和常量池引用![截屏2020-08-17 上午10.51.27](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 上午10.51.27.png)



总结class文件的组织形式为：

1. magic Number
2. version
3. 常量表长度，常量表
4. 类的访问标志
5. 类索引、父类索引和接口索引
6. 字段表长度，字段表
7. 方法表长度，方法表

### 2.字节码

- 字节码由两部分组成，Opcode和Operand，由于Java虚拟机面向操作数栈而非寄存器，大多数指令只有Opcode

  - Opcode的长度为1个字节，故指令最多只有255种

  - Operand不要求对其，长度不固定

  - ```java
    do {
    		自动计算PC寄存器的值加1; 
      	根据PC寄存器指示的位置，从字节码流中取出操作码; 
      	if (字节码存在操作数) 从字节码流中取出操作数; 
      	执行操作码所定义的操作;
    } while (字节码流长度 > 0);
    
    ```

- 为了用255表示完所有的指令，每种类型的指令和数据类型不可能一一对应，存在类型转换来实现，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类 型作为运算类型(Computational Type)来进行的，如下表所示：![截屏2020-08-17 下午12.21.23](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 下午12.21.23.png)

#### 9种字节码指令

- 加载和保存指令

  - Tload，从局部变量表中加载数据到操作数栈中

  - Tstore，从操作数栈中将数据储存到局部变量表中

  - 将一个常量加载到操作数栈:bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、

    iconst_\<i>、lconst_\<l>、fconst_\<f>、dconst_\<d>

  - 扩充局部变量表的访问索引的指令:wide

- 运算指令

  - 加法指令:iadd、ladd、fadd、dadd 
  - 减法指令:isub、lsub、fsub、dsub 
  - 乘法指令:imul、lmul、fmul、dmul 
  - 除法指令:idiv、ldiv、fdiv、ddiv 
  - 求余指令:irem、lrem、frem、drem 
  - 取反指令:ineg、lneg、fneg、dneg 
  - 位移指令:ishl、ishr、iushr、lshl、lshr、lushr 
  - 按位或指令:ior、lor （只支持整型）
  - 按位与指令:iand、land 
  - 按位异或指令:ixor、lxor 
  - 局部变量自增指令:iinc
  - 比较指令:dcmp g、dcmp l、fcmp g、fcmp l、lcmp

- 类型转化指令

  - 宽化类型转化（无损失）int->long等
  - 窄化类型转化（有损失）i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f
    - 尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是《Java虚拟机规 范》中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。

- 对象创建和访问指令

  - 创建类实例的指令:new
  - 创建数组的指令:new array 、anew array 、mult ianew array
  - 访问类字段(static字段，或者称为类变量)和实例字段(非static字段，或者称为实例变量)的 指令:getfield、putfield、getstatic、putstatic
  - 把一个数组元素加载到操作数栈的指令:baload、caload、saload、iaload、laload、faload、 daload、aaload
  - 将一个操作数栈的值储存到数组元素中的指令:bastore、castore、sastore、iastore、fastore、 dastore、aastore
  - 取数组长度的指令:array lengt h 
  - 检查类实例类型的指令:inst anceof、checkcast

- 操作数栈管理指令

  - 将操作数栈的栈顶一个或两个元素出栈: pop 、pop 2
  - 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶:dup 、dup 2、dup _x1、 dup 2_x1、dup _x2、dup 2_x2
  - 将栈最顶端的两个数值互换:swap

- 控制转移指令
  - 条 件 分 支 :  i f e q 、 i f l t 、 i f l e 、 i f n e 、 i f gt 、 i f ge 、 i f n u l l 、 i f n o n n u l l 、 i f _ i c m p e q 、 i f _ i c m p n e 、 i f _ i c m p l t 、 i f _ i c m p gt 、 i f _ i c m p l e 、 i f _ i c m p ge 、 i f _ a c m p e q 和 i f _ a c m p n e
    - **各种类型的比较最终都会转化为int类型的比较操作**
  - 复合条件分支:tableswitch、lookupswitch
  - 无 条 件 分 支 : go to 、 go to_w 、 jsr 、 jsr_w 、 r e t

- 方法调用和返回指令
  - invokevirt ual指令:用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派)， 这也是Java语言中最常见的方法分派方式。
  - invokeint erface指令:用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找 出适合的方法进行调用。
  - invokesp ecial指令:用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和 父类方法。
  - invokestatic指令:用于调用类静态方法(static方法)。
  - invokedy namic指令:用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面 四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedy namic指令的分派逻辑 是由用户所设定的引导方法决定的。
  - 方法返回指令：ireturn(当返 回值是boolean、byte、char、short和int类型时使用)、lreturn、freturn、dreturn和areturn，另外还有一 条ret urn指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。
- 异常处理指令
  
  - athrow
- 同步指令
  
  - Java虚拟机的指令集中 有monitorenter和monitorexit两条指令来支持synchronized关键字的语义

总结9种指令集的构成：

1. 加载和储存指令
2. 计算指令
3. 方法调用和返回指令
4. 异常指令
5. 同步指令
6. 类型转化指令
7. 控制转移指令
8. 对象创建和访问指令
9. 操作数栈管理指令

### 3.虚拟机加载class文件

虚拟机的实现

- 将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集; 
- 将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集(即即时编译器代码生成技术)。

> 虚拟机在后台如何处理优化class文件有多种方式，只要保证实现的语义相同即可

> 在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，编写一个面向接口的应用程序，可以等到运行时再指定其 实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络 或其他地方上加载一个二进制流作为其程序代码的一部分。这种动态组装应用的方式目前已广泛应用 于Java程序之中，从最基础的Applet、JSP到相对复杂的OSGi技术，都依赖着Java语言运行期类加载才 得以诞生。

- 类加载的生命周期![截屏2020-08-17 下午2.29.58](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 下午2.29.58.png)

#### 类加载的时期

- 类只在6种情况下会主动加载，其余情况下只会被引用时加载

#### 类的加载过程

1. 通过一个类的全限定名来获取定义此类的二进制字节流（字节码）
   1. 从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。
   2. 从网络中获取，这种场景最典型的应用就是Web Applet。
   3. 运 行 时 计 算 生 成 ， 这 种 场 景 使 用 得 最 多 的 就 是 动 态 代 理 技 术 ，
   4. 由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。 ·从数据库中读取，这种场景相对少见些，例如有些中间件服务器(如SAP Netweaver)可以选择把程序安装到数据库中来完成程序代码在集群间的分发。
   5. 可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文 件来保障程序运行逻辑不被窥探。
2. 将这个字节流所代表的静态存储结构转化为**方法区**的运行时数据结构。
3. 在内存中（**堆区域**）生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

#### 类的验证过程

1. 文件格式验证，在二进制数据流的基础上完成验证，验证完成后进入方法区进行储存（文件相关）
   1. 是否以魔数0xCAFEBABE开头。 
   2. 主、次版本号是否在当前Java虚拟机接受范围之内。 
   3. 常量池的常量中是否有不被支持的常量类型(检查常量tag标志)。 。。。
2. 元数据验证（声明、基础相关）
   1. 这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)。
   2. 这个类的父类是否继承了不允许被继承的类(被final修饰的类)。
   3. 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
3. 字节码验证，对类的方法体的**Code属性表**，通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的（具体代码相关）
   1. 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。
   2. 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
   3. 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全 的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个 数据类型，则是危险和不合法的。
4. 符号引用验证（运行相关）
   1. 符号引用中通过字符串描述的全限定名是否能找到对应的类。
   2. 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
   3. 符号引用中的类、字段、方法的可访问性(private、protected、public、<package>)是否可被当 前类访问。

总结，类的验证过程非常重要但并不是必要的，对于反复验证的代码可以关闭该过程来提高运算的效率

#### 类的准备过程

> 相当于一个内存分配的过程

- 为类中定义的变量(即静态变量，被static修饰的变量)分配内存并设置类变量初始值
- 各基本类型设置为初始值而非代码中定义的值![截屏2020-08-17 下午2.58.24](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 下午2.58.24.png)

#### 类的解析过程

> 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程

- **符号引用**(Symbolic References):符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。
- **直接引用**(Direct References):直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

1. 类/接口的解析
   1. 使用类加载器将符号引用绑定至直接引用
2. 字段解析
   1. 先解析出方法表的class_index项中索引的字段所属的类或接口的符号引用
   2. 在类或接口的直接引用中查找该字段，未找到则递归查找父级
3. 类方法解析
   1. 同字段解析类似
4. 接口方法解析
   1. 同字段解析类似

#### 类的初始化过程

> 进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通 过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表 达:初始化阶段就是执行类构造器<clinit>()方法的过程。

- <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的 语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问 到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问
- 只对有static数据的类生成，父类优先于子类，接口也会生成<clinit>()方法
- 一个类的<clinit >()方法在多线程环境中被正确地加锁同步

#### 类加载器：完成上述步骤的函数

> Java虚拟机设计团队有意把类加载阶段中的“**通过一个类的全限定名来获取描述该类的二进制字节流**”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动 作的代码被称为“类加载器”(Class Loader)。

Java虚拟机中可以将类加载器分为以下两种

- 启动类加载器(Bootstra ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分
- 其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader

类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每 一个类加载器，都拥有一个独立的类名称空间

##### Java基于三层类加载器、双亲委派的类加载架构

1. 启动类加载器(Bootstrap Class Loader):前面已经介绍过，这个类加载器负责加载存放在 <JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够 识别的(按照文件名识别，如rt.jar、t ools.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时， 如果需要把加载请求**委派给引导类加载器**去处理，那直接使用null代替即可
2. 扩展类加载器(Extension Class Loader):这个类加载器是在类sun.misc.Launcher$ExtClassLoader 中以Java代码的形式实现的。它负责加载<JAVA_HOM E>\lib\ext目录中，或者被java.ext.dirs系统变量所 指定的路径中所有的类库。根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩 展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK 9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。由于扩展类加载器是由Java代码实现的，开发者可以**直接在程序中使用**扩展类加载器来加载Class文件。
3. 应用程序类加载器(Application Class Loader):这个类加载器由sun.misc.Launcher$App ClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径 (ClassPath)上所有的类库，开发者同样可以**直接在代码中使用这个类加载器**。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是**程序中默认的类加载器**。

##### 双亲委派机制的层次

> 除了顶层的启动类加载器外，其余的类加载器都应有自己的**父类加载**器。不过这里类加载器之间的父子关系一般不是以继承(Inherit ance)的关系来实现的，而是通常使用 组合(Composition)关系来复用父加载器的代码。
>
> 如果一个类加载器收到了类加载的请求，它**首先不会自己去尝试加 载这个类**，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的 加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请 求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去完成加载

<img src="/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 下午5.29.37.png" alt="截屏2020-08-17 下午5.29.37" style="zoom:30%;" />

引入双亲委派机制的主要目的是：

1. 防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。虚拟机只有在两个类的类名相同且加载该类的加载器均相同的情况下才判定这是一个类。若不采用双亲委派机制，同一个类有可能被多个类加载器加载，这样该类会被识别为两个不同的类，相互赋值时会有问题。双亲委派机制能保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。 
2. 保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。

##### 破坏双亲委派机制

> 为什么要破坏双亲委派机制？
>
> 1. 模型的自身缺陷：基础类型无法调用回用户的代码，如JDNI服务需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口(Service Provider Interface，SPI)的代码
> 2. 在大型的Java Web应用中，类加载的过程有着更高的动态性需求，如实现热插拔、模块化部署等，典型的案例就是OSGi实现的同级类加载器查找

### 4.运行时的栈帧结构

> 每一个方法就是一个线程，在方法中调用其他方法相当于创建一个新的栈帧并压入虚拟机栈

在不同的虚拟机实现中，执行引擎在执行字节码的时候，通常会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择

- **Java虚拟机以方法作为最基本的执行单元**，“栈帧”(Stack Frame)则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈(Virtual MachineStack)[1]的栈元素。
- 栈帧存储了方法的**局部变量表**、**操作数栈**、**动态连接**和**方法返回地址**（方法区中的引用）等信息，**每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。<img src="/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-17 下午6.02.17.png" alt="截屏2020-08-17 下午6.02.17" style="zoom:100%;" />**

#### 局部变量表

- 局部变量表的容量以变量槽(Variable Slot)为最小单位，一般为32位
- Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变 量槽数量
- 局部变量表中第0位索 引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数

#### 操作数栈

- 操作数栈(Operand Stack)也常被称为操作栈，它是一个后入先出(Last In First Out，LIFO) 栈 。
- 例如整数加法的字节码指令iadd，这条指令在运行的时候要 求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int 值出栈并相加，然后将相加的结果重新入栈。

#### 动态链接

- 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。
- Class文件的常量池中存 有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。
  - 这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。 
  - 另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

#### 返回地址

当一个方法开始执行后，只有两种方式退出

1. 执行引擎遇到任意一个方法 返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用 者或者主调方法)，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为“正常调用完成”(Normal Method Invocation Completion)。
2. 在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方 法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为“异常调用 完成(Abrupt Method Invocation Completion)”。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的

### 5.方法调用

和Java在类加载时的动态性相同，方法调用阶段唯一的任务就是确定被调用方法的版本 (即调用哪一个方法)，暂时还未涉及方法内部的具体运行过程

- invokestatic。用于调用静态方法。
- invokespecial。用于调用实例构造器<init>()方法、私有方法和父类中的方法。 
- **invokevirtual**。用于调用所有的虚方法。
- invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象。
- invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4 条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。

#### 解析

类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的 提是:方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析

- Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法

#### 分派

> 实现Java语言多态的特性

1. 静态分派以实现重载overload，用输入的类型来确定执行的具体方法

```java
   public class StaticDispatch {
       static abstract class Human {
       }
   
       static class Man extends Human {
       }
   
       static class Woman extends Human {
       }
   
       public void sayHello(Human guy) {
           System.out.println("hello,guy!");
       }
   
       public void sayHello(Man guy) {
           System.out.println("hello,gentleman!");
       }
   
       public void sayHello(Woman guy) {
           System.out.println("hello,lady!");
       }
   
       public static void main(String[] args) {
           Human man = new Man();
           Human woman = new Woman();
           StaticDispatch sr = new StaticDispatch();
           sr.sayHello(man);
           sr.sayHello(woman);
       }
   }
```

示例代码的输出为

```java
"hello,guy!"
"hello,guy!"
```

- “Human”称为变量的“静态类型”(Static Type)，或者叫“外观类 型”(Apparent Type)

- 后面的“Man”则被称为变量的“实际类型”(Actual Type)或者叫“运行时类 型”(Runtime Type)

所有**依赖静态类型**来决定方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用表 现就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行 的，这点也是为何一些资料选择把它归入“解析”而不是“分派”的原因。

2. 动态分派以实现重写override，用类实例的实际类型来确定方法

```java
public class DynamicDispatch {
    static abstract class Human {
        protected abstract void sayHello();
    }

    static class Man extends Human {
        @Override
        protected void sayHello() {
            System.out.println("man say hello");
        }
    }

    static class Woman extends Human {
        @Override
        protected void sayHello() {
            System.out.println("woman say hello");
        }
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
        man.sayHello();
    }
}
```

运行的结果为

```java
"man say hello"
"woman say hello"
"woman say hello"
```

正是因为invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的 invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。我们把这种**在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。**

这种现象的根源在于invokevirtual指令的执行逻辑

1. 找到操作数栈顶的第一个元素所指向的对象的**实际类型**，记作C。
   - 这里找的是实际类型！即实例
2. 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;不通过则返回java.lang.IllegalAccessError异常。
3. 否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。
4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

#### 总结

Java语言是一门静态多分派、动态单分派的语言！

Overload：在编译器阶段实现静态多分派，即根据变量的声明类型来确定其类型从而确定调用的方法

Override：在运行阶段实现动态单分派，即根据receiver的类型和参数来确定调用的方法

- 不同的虚拟机有不同的动态分派实现形式，如对每一个类建立虚方法表
- 与此对应的，在invokeinterface执行时也 会用到接口方法表——Interface Method Table，简称itable

### 解释执行

编译过程，包含两种执行过程

![截屏2020-08-18 上午10.55.02](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-18 上午10.55.02.png)

基于栈的指令集和基于寄存器的指令集的优劣

- 基于寄存器运行速度快，指令少，但与硬件平台相关，不同平台不一样
- 基于栈运行速度慢（栈在内存中），代码紧凑但指令多，与硬件平台无关



















































