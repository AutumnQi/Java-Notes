# 垃圾收集器与内存分配策略

### 如何判断堆中的对象已死

1. Reference Counting 无法解决相互引用的对象，需要配合大量的额外处理才能保证工作（主流的虚拟机都未采用）
2. Tracing 从一些根节点出发，认为无法到达的对象为垃圾对象

Tracing的根节点包括以下：

- 虚拟机线程栈帧中的引用到的变量
- 方法区中类静态属性引用的变量
- 本地方法栈中引用的对象
- 虚拟机内部的引用，如基本类型对应的class对象
- 所有被同步锁持有的对象
- ....

为了更为精细的GC管理，JDK 1.2版本后将引用分为了4个级别：

- 强引用：类似 Object obj=new Object() **始终存活**
- 软引用：一些还有用，但非必须的对象 **可以在内存还充足的时候一直存活**
- 弱引用：非必须对象 **在下一次GC时会被回收**
- 虚引用：为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知

在使用Tracing完成对不可达对象的标记后，仍要进行一次筛选，判断该对象是否有finalize方法，有且未被执行过的话会将其放到一个F-Queue队列中来执行其finalize方法，若在一定时间内盖对象与存活对象建立联系，则可完成自救，但只允许自救一次。但该方法是为了让C++的析构概念在Java中实现，属于历史遗留问题，不推荐使用。

### 回收方法区

方法区的垃圾收集主要回收两部分内容:废弃的常量和不再使用的类型。

- 判断常量可回收：不存在对其的直接引用
- 判断类可回收：
  - 所有实例已被回收
  - class对象没有被引用
  - 类加载器被回收

回收方法区的主要目的是在频繁自定义类加载器的情况下，保证方法区的内存占比不会过大

### 垃圾收集算法

#### 分代垃圾收集

基础假定：

- 弱分代假说(Weak Generational Hypothesis):绝大多数对象都是朝生夕灭的。
- 强分代假说(Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象就越难以消亡。

简而言之，在新生代对象中，消亡的占大多数，故在内存回收时采用复制的方法来进行（存活少），而在老年代中，存活的占大多数，采用整理的方式来做内存回收，综合内存的利用和计算时间。

在新生代对象范围中做GC，然而可能会遇到老年代的对象对其的跨代引用，故在常规的GC root之外，还要从老年代出发去做一次tracing，而这是一项开销非常大的行为，由此引出了下面的假设：

- 跨代引用假说(Intergenerational Reference Hypothesis):跨代引用相对于同代引用来说仅占极少数。

在此基础上，我们只需要维护一个全局的数据结构Remember Set，用来存储“**存在跨代引用的老年代块**”，在进行Minor GC时，对Set中存储的部分做tracing即可

#### 几种GC机制的分类

1. Partial GC
   1. Minor GC：对新生代对象做GC
   2. Major GC：对老年代对象做GC，只有CMS收集器会执行
   3. Mixed GC：同时对两块区域做GC，g1收集器的特性
2. Full GC：收集全部的堆和方法区

#### 几种垃圾收集算法

1. 标记-清除：
   - 执行效率不稳定，执行时间和对象数量挂钩
   - 会产生内存碎片降低内存使用率
2. 标记-复制
   - 将内存分为两块区域，每当当前区域已满时，将仍然存活的对象复制到另外一块区域中
   - HotSpot使用该方法进行新生代的回收，将新生代分为8:1:1的Eden和两个survivor区，每次在survivor区循环倒腾（理论基础为弱分代假说，有98%的新生代对象熬不过第一轮GC，故整体的开销不大）
3. 标记-整理
   - 如果存活的对象比例高，需要大量的额外空间来做复制的备份时使用标记-复制就不是很合适了，此时若使用标记-清除则会产生大量的内存碎片，在此基础上提出了标记-整理算法，将所有存活的对象进行压缩以回收内存
   - 在执行整理的阶段，由于对象的移动，用户线程无法继续执行，故存在一个stop the world的现象，然而从总体来看，有助于系统吞吐量的提升！（过多的内存碎片需要额外的开销来解决）

HotSpot中，强调低延迟的CMS收集器是基于标记-清除的（内存碎片过多再进行整理），而强调吞吐量的Parallel等则是采用标记-整理的方式

#### HotSpot细节实现

1. 根节点枚举，[参考博客](https://www.cnblogs.com/strinkbug/p/6376525.html?utm_source=itdadao&utm_medium=referral)
   - 根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化
   - 即使是号称停顿时间可控，或者(几乎)不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的
   - HotSpot使用**准确式GC**，即需要知道对象的哪一块储存的是什么类型，在每个方法（线程）中使用OopMap来记录对象的位置，包括内存和寄存器，如此一来可以直接得到这些对象的引用地址！方便root的枚举
   - 对于没有OopMap的JNI本地方法，采用的是通过具柄（handler）的方式来调用相关的对象，只需要遍历具柄表即可
2. 安全点 SafePoint
   - 在OopMap的帮助下，HotSpot可以迅速完成GC root的枚举，但为每一个指令生成一个OopMap开销过大，故规定了一些生成OopMap的点称为安全点
   - HotSpot将GC设置为主动中断的过程，mutator通过轮询的方式来确认是否需要进行GC（用一个test指令访问内存），一旦确认需要则在下一个Safepoint挂起
3. 安全区
   - 有一些线程自身处在sleep和wait的阶段，无法到达Safepoint，需要建立一个安全区的概念，GC不去干涉里面的线程
4. 记忆集与卡表

   - Remember Set用来记录那些具有新生代引用的老年代对象块
   - 卡表是记忆集的一种实现形式，使用固定大小的卡来容纳老年代对象
5. 写屏障
   - 完成卡表的维护，变脏时间点原则上应该发生在引用类型字段赋值的那一刻，使用写屏障来完成变脏的过程，将变脏的过程集成到机器码指令中，把维护卡表的动作放到每一个赋值操作之中。
   - 写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形(Around)通知，供程序执行额外的动作，也就是说赋值的 前后都在写屏障的覆盖范畴内
6. 并发的tracing
   - 白色：未被访问；灰色：自身被访问但子节点未被完全访问；黑色：自身和子节点都被完全访问
   - mutator和GC线程并发可能导致的问题：
     - 本应被删除的对象重获引用后继续留存
     - 不该被删除的对象失去引用后消失（严重错误）
   - 并发导致对象消失
     - 错误1: 赋值器插入了一条或多条从黑色对象到白色对象的新引用; 
     - 错误2: 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。
   - 破坏这两种方式即可保证不发生对象消失
     - 增量更新(Incremental Update) 黑色对象新增引用后变为灰色 `CMS`
     - 原始快照(Snapshot At The Beginning， SATB ) 记录被删除的灰-白连接，重新扫描 `G1`、`Shenandoah`

#### HotSpot用到的垃圾收集器

- 新生代：Serial Parallel Parallel New（注重停顿时间） Parallel Scavenge（注重吞吐量）
- 老年代：Serial Old Parallel Old CMS
- 不区分新生代和老年代：Garbage First

1. CMS Concurrent Mark Sweep （针对老年代的收集器）
   1. ![截屏2020-08-27 下午4.57.44](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-27 下午4.57.44.png)
   2. 仅在初始标记和重新标记处需要stop the world，**目标为减少用户进程的停顿时间**，不在意吞吐量
   3. CMS的优点
      - 并发收集、低停顿
   4. CMS收集器的缺点
      - 对处理器资源非常敏感（并发标记和清除需要占据大量的cpu资源）
      - 无法处理“浮动垃圾”(即标记过程完后成为垃圾的对象)，需要额外空出内存来避免浮动垃圾超限
      - CMS是一款基于“标记-清除”算法实现的收集器，容易造成内存碎片
2. Garbage First
   1. ![截屏2020-08-27 下午5.20.29](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-27 下午5.20.29.png)
   2. G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理 论设计的，但其堆内存的布局与其他收集器有非常明显的差异:G1不再坚持固定大小以及固定数量的 分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。
   3. 在收集的过程中，也可以按块来进行回收，从而完成和用户线程互不干扰的并行，优先回收有垃圾的块（Garbage First）
   4. 面向堆内存任何部分来组成回收集(Collection Set，一般简称CSet)进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多
   5. G1采用标记-复制的方式来做垃圾的清除，可以在图中看到**该阶段是Stop the World**的，并非并发进行，这段时间是可以指定一个最大上限的
   6. G1的缺点
      - 每个region都要维护一个卡表，造成卡表的空间占用可能高达20%以上
      - G1无论是为了垃圾收集产生的内存占用(Footprint)还是程序运行时的额外执行负载 (Overload)都要比CM S要高

CMS和G1是现阶段共存的两款优秀的垃圾回收器，目前来看两个仍处于各有优劣的情况，不同的情况有不同的应用选择：

- 在小内存应用上CM S的表现大概率仍然要会优于G1
- 在大内存应用上G1则大多能发挥其 优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间

> 当然以上也都是经验之谈，最好还是需要实践出真知

#### 未来发展方向

衡量垃圾收集器的三项最重要的指标是:内存占用(Footprint)、吞吐量(Throughput)和延迟(Latency)，三者构成了一个不可能三角，随着内存越来越大，后两项指标变得越来越重要。

各款收集器的并发情况如下图所示：

![截屏2020-08-31 下午11.02.38](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-31 下午11.02.38.png)

#### Shenandoah收集器

**目标：**尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟

![截屏2020-08-31 下午11.08.02](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-31 下午11.08.02.png)

最大的区别在于实现了并发的复制整理，先做复制，再做引用修正，通过读屏障和被称为“Brooks Pointers”的转发指针来解决。

最终的效果如下：

![截屏2020-08-31 下午11.11.30](/Users/inlab/Library/Application Support/typora-user-images/截屏2020-08-31 下午11.11.30.png)

#### ZGC

。。。